#!/usr/bin/env bash
set -euo pipefail

# ============================================================================
# agent-env — Universal secret injection for AI coding agents
# https://github.com/jordanburke/agent-env
# ============================================================================

VERSION="0.2.0"
PROGRAM="agent-env"

# Colors (disabled if neither stdout nor stderr is a terminal)
if [[ -t 1 || -t 2 ]]; then
  RED=$'\033[0;31m'
  GREEN=$'\033[0;32m'
  YELLOW=$'\033[0;33m'
  BLUE=$'\033[0;34m'
  CYAN=$'\033[0;36m'
  DIM=$'\033[0;2m'
  BOLD=$'\033[1m'
  RESET=$'\033[0m'
else
  RED='' GREEN='' YELLOW='' BLUE='' CYAN='' DIM='' BOLD='' RESET=''
fi

VERBOSE=0
FORCE_MODE=""       # "sops" or "dotenv" or ""
EXPLICIT_FILE=""    # user-specified secrets file
NO_GLOBAL=0         # skip global secrets layer

# ---------------------------------------------------------------------------
# Logging
# ---------------------------------------------------------------------------
info()    { printf "${BLUE}info${RESET}  %s\n" "$*" >&2; }
warn()    { printf "${YELLOW}warn${RESET}  %s\n" "$*" >&2; }
error()   { printf "${RED}error${RESET} %s\n" "$*" >&2; }
debug()   { [[ "$VERBOSE" -eq 1 ]] && printf "${DIM}debug %s${RESET}\n" "$*" >&2 || true; }
success() { printf "${GREEN}ok${RESET}    %s\n" "$*" >&2; }

die() {
  error "$@"
  exit 1
}

# ---------------------------------------------------------------------------
# Utility
# ---------------------------------------------------------------------------
command_exists() {
  command -v "$1" &>/dev/null
}

git_root() {
  git rev-parse --show-toplevel 2>/dev/null
}

is_sops_file() {
  local file="$1"
  [[ -f "$file" ]] || return 1
  # SOPS YAML format starts with "sops:" metadata block
  # SOPS dotenv format has "sops_version=" and "ENC[" markers
  head -5 "$file" | grep -q "^sops:" && return 0
  grep -q "^sops_version=" "$file" && return 0
  return 1
}

detect_mode() {
  local file="$1"
  if [[ -n "$FORCE_MODE" ]]; then
    echo "$FORCE_MODE"
  elif is_sops_file "$file"; then
    echo "sops"
  else
    echo "dotenv"
  fi
}

# ---------------------------------------------------------------------------
# File Discovery
#
# Split into project-level and global discovery for layered loading.
# SOPS files take priority over dotenv when both exist in the same directory.
# ---------------------------------------------------------------------------

# Discover project-level secrets: walk from PWD up to git root.
# Does NOT check global fallback locations.
discover_project_file() {
  if [[ -n "$EXPLICIT_FILE" ]]; then
    if [[ -f "$EXPLICIT_FILE" ]]; then
      echo "$EXPLICIT_FILE"
      return 0
    else
      die "Specified secrets file not found: $EXPLICIT_FILE"
    fi
  fi

  local stop_at
  stop_at="$(git_root)" || stop_at=""

  local dir
  dir="$(pwd -P)"

  while true; do
    debug "Searching project: $dir"

    if [[ -f "$dir/.sops.env" ]]; then
      debug "Found project: $dir/.sops.env"
      echo "$dir/.sops.env"
      return 0
    fi

    if [[ -f "$dir/.env" ]]; then
      debug "Found project: $dir/.env"
      echo "$dir/.env"
      return 0
    fi

    if [[ -n "$stop_at" && "$dir" == "$stop_at" ]]; then
      debug "Reached git root: $stop_at"
      break
    fi

    local parent
    parent="$(dirname "$dir")"
    if [[ "$parent" == "$dir" ]]; then
      break
    fi
    dir="$parent"
  done

  return 1
}

# Discover global secrets: check only global fallback locations.
discover_global_file() {
  local -a fallbacks=(
    "${XDG_CONFIG_HOME:-$HOME/.config}/agent-env/.sops.env"
    "${XDG_CONFIG_HOME:-$HOME/.config}/agent-env/.env"
    "$HOME/.sops.env"
    "$HOME/.env"
  )

  for fb in "${fallbacks[@]}"; do
    debug "Checking global: $fb"
    if [[ -f "$fb" ]]; then
      debug "Found global: $fb"
      echo "$fb"
      return 0
    fi
  done

  return 1
}

# Legacy wrapper: find project file first, fall back to global.
# Used by edit, view, check commands.
discover_secrets_file() {
  if discover_project_file; then
    return 0
  fi
  discover_global_file
}

# ---------------------------------------------------------------------------
# SOPS Helpers
# ---------------------------------------------------------------------------

# Ensure SOPS_AGE_KEY_FILE is set if the default key file exists
ensure_age_key() {
  if [[ -z "${SOPS_AGE_KEY_FILE:-}" ]]; then
    local default_key="${XDG_CONFIG_HOME:-$HOME/.config}/sops/age/keys.txt"
    if [[ -f "$default_key" ]]; then
      export SOPS_AGE_KEY_FILE="$default_key"
      debug "Auto-set SOPS_AGE_KEY_FILE=$default_key"
    fi
  fi
}

# ---------------------------------------------------------------------------
# Dependency Checks
# ---------------------------------------------------------------------------
check_sops_deps() {
  ensure_age_key
  local ok=1
  if ! command_exists sops; then
    error "sops is required for encrypted secrets but not found"
    printf "  Install: ${CYAN}brew install sops${RESET} or ${CYAN}https://github.com/getsops/sops${RESET}\n" >&2
    ok=0
  fi
  if ! command_exists age; then
    warn "age not found (needed if your SOPS file uses age encryption)"
    printf "  Install: ${CYAN}brew install age${RESET} or ${CYAN}https://github.com/FiloSottile/age${RESET}\n" >&2
  fi
  [[ "$ok" -eq 1 ]]
}

# ---------------------------------------------------------------------------
# Secret Loading
#
# Loads a secrets file into the current environment. For SOPS files, decrypts
# to a temp file, sources it, then cleans up. For dotenv, sources directly.
# ---------------------------------------------------------------------------
load_secrets_file() {
  local file="$1"
  local label="${2:-secrets}"

  local mode
  mode="$(detect_mode "$file")"
  debug "Loading $label: $file (${mode})"

  case "$mode" in
    sops)
      check_sops_deps || exit 1
      local tmpfile
      tmpfile="$(mktemp "${TMPDIR:-/tmp}/agent-env.XXXXXX")"
      trap "rm -f '$tmpfile'" EXIT
      sops --decrypt --output-type dotenv "$file" > "$tmpfile" || die "Failed to decrypt $file"
      set -a
      # shellcheck source=/dev/null
      source "$tmpfile"
      set +a
      rm -f "$tmpfile"
      ;;
    dotenv)
      set -a
      # shellcheck source=/dev/null
      source "$file"
      set +a
      ;;
    *)
      die "Unknown mode: $mode"
      ;;
  esac
}

# ---------------------------------------------------------------------------
# Subcommand: run
# ---------------------------------------------------------------------------
cmd_run() {
  local args=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -v|--verbose) VERBOSE=1; shift ;;
      --sops)       FORCE_MODE="sops"; shift ;;
      --dotenv)     FORCE_MODE="dotenv"; shift ;;
      --env|--secrets) EXPLICIT_FILE="$2"; shift 2 ;;
      --env=*|--secrets=*) EXPLICIT_FILE="${1#*=}"; shift ;;
      --no-global)  NO_GLOBAL=1; shift ;;
      -*)           die "Unknown run option: $1 (use '$PROGRAM help' for usage)" ;;
      *)            args+=("$@"); break ;;
    esac
  done

  if [[ ${#args[@]} -eq 0 ]]; then
    die "No agent command specified. Usage: $PROGRAM run <agent> [args...]"
  fi

  local agent="${args[0]}"
  local agent_args=()
  if [[ ${#args[@]} -gt 1 ]]; then
    agent_args=("${args[@]:1}")
  fi

  # Resolve agent to full path
  local agent_path
  agent_path="$(command -v "$agent" 2>/dev/null)" || die "Agent not found: $agent"
  debug "Agent resolved: $agent_path"

  # Discover secrets files (layered: global base + project overlay)
  local global_file="" project_file=""

  if [[ "$NO_GLOBAL" -eq 0 ]]; then
    global_file="$(discover_global_file)" || true
  fi

  project_file="$(discover_project_file)" || true

  # If project file is the same as global file, don't double-load
  if [[ -n "$project_file" && "$project_file" == "$global_file" ]]; then
    global_file=""
  fi

  if [[ -z "$global_file" && -z "$project_file" ]]; then
    die "No secrets file found. Run '$PROGRAM init' to create one, or use --env FILE."
  fi

  # Layer 1: Global secrets (base)
  if [[ -n "$global_file" ]]; then
    info "Global:  $global_file"
    load_secrets_file "$global_file" "global"
  fi

  # Layer 2: Project secrets (overlay — overrides global)
  if [[ -n "$project_file" ]]; then
    info "Project: $project_file"
    load_secrets_file "$project_file" "project"
  fi

  # Exec the agent
  debug "Secrets loaded, exec-ing $agent_path"
  if [[ ${#agent_args[@]} -gt 0 ]]; then
    exec "$agent_path" "${agent_args[@]}"
  else
    exec "$agent_path"
  fi
}

# ---------------------------------------------------------------------------
# Subcommand: init
# ---------------------------------------------------------------------------
cmd_init() {
  local use_sops=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --sops) use_sops=1; shift ;;
      *)      die "Unknown init option: $1" ;;
    esac
  done

  if [[ "$use_sops" -eq 1 ]]; then
    local target=".sops.env"
    if [[ -f "$target" ]]; then
      die "$target already exists"
    fi

    check_sops_deps || exit 1

    # Check for .sops.yaml config
    if [[ ! -f ".sops.yaml" ]]; then
      warn "No .sops.yaml found. Creating a default one..."

      local age_key_file="${SOPS_AGE_KEY_FILE:-$HOME/.config/sops/age/keys.txt}"
      local age_pub=""

      if [[ -f "$age_key_file" ]]; then
        age_pub="$(grep -o 'age1[a-z0-9]*' "$age_key_file" | head -1)" || true
      fi

      if [[ -z "$age_pub" ]]; then
        warn "No age key found. Generate one with: age-keygen -o $age_key_file"
        warn "Then add the public key to .sops.yaml"
        age_pub="age1your-public-key-here"
      fi

      cat > .sops.yaml <<EOF
creation_rules:
  - path_regex: \.sops\.env$
    age: >-
      $age_pub
EOF
      success "Created .sops.yaml"
    fi

    # Create an empty encrypted file
    printf "# Add your secrets below\n# KEY=value\n" | sops --encrypt --input-type dotenv --output-type dotenv /dev/stdin > "$target" 2>/dev/null \
      || printf "# Add your secrets below (encrypt with: sops --encrypt --in-place %s)\n# KEY=value\n" "$target" > "$target"

    success "Created $target"
    info "Edit with: $PROGRAM edit"
  else
    local target=".env"
    if [[ -f "$target" ]]; then
      die "$target already exists"
    fi

    cat > "$target" <<'EOF'
# agent-env secrets — loaded automatically by agent-env
# Add API keys and secrets below
#
# OPENAI_API_KEY=sk-...
# ANTHROPIC_API_KEY=sk-ant-...
# GITHUB_TOKEN=ghp_...
EOF

    success "Created $target"
    info "Edit with: \$EDITOR $target"

    # Ensure .gitignore includes .env
    if [[ -f ".gitignore" ]]; then
      if ! grep -qx '.env' .gitignore 2>/dev/null; then
        echo '.env' >> .gitignore
        info "Added .env to .gitignore"
      fi
    else
      echo '.env' > .gitignore
      info "Created .gitignore with .env"
    fi
  fi
}

# ---------------------------------------------------------------------------
# Subcommand: edit
# ---------------------------------------------------------------------------
cmd_edit() {
  local secrets_file
  secrets_file="$(discover_secrets_file)" || \
    die "No secrets file found. Run '$PROGRAM init' to create one."

  local mode
  mode="$(detect_mode "$secrets_file")"

  case "$mode" in
    sops)
      check_sops_deps || exit 1
      info "Opening SOPS editor for $secrets_file..."
      exec sops "$secrets_file"
      ;;
    dotenv)
      local editor="${EDITOR:-${VISUAL:-vi}}"
      info "Opening $secrets_file with $editor..."
      exec "$editor" "$secrets_file"
      ;;
  esac
}

# ---------------------------------------------------------------------------
# Subcommand: view
# ---------------------------------------------------------------------------
cmd_view() {
  local secrets_file
  secrets_file="$(discover_secrets_file)" || \
    die "No secrets file found. Run '$PROGRAM init' to create one."

  local mode
  mode="$(detect_mode "$secrets_file")"

  info "Secrets file: $secrets_file (${mode})"

  case "$mode" in
    sops)
      check_sops_deps || exit 1
      sops --decrypt "$secrets_file"
      ;;
    dotenv)
      cat "$secrets_file"
      ;;
  esac
}

# ---------------------------------------------------------------------------
# Subcommand: check
# ---------------------------------------------------------------------------
cmd_check() {
  local all_ok=1
  ensure_age_key

  printf "\n${BOLD}agent-env v%s — environment check${RESET}\n\n" "$VERSION" >&2

  # Check a single secrets file and report status
  _check_file() {
    local label="$1" file="$2"

    printf "  ${BOLD}%s${RESET}\n" "$label" >&2

    local mode
    mode="$(detect_mode "$file")"
    success "  File: $file (${mode})"

    if [[ "$mode" == "sops" ]]; then
      if command_exists sops; then
        if sops --decrypt "$file" &>/dev/null; then
          success "  Decryption: working"
        else
          error "  Decryption: failed (check keys)"
          all_ok=0
        fi
      else
        error "  sops: not installed"
        all_ok=0
      fi
    else
      if [[ -r "$file" ]]; then
        success "  File readable: yes"
      else
        error "  File readable: no"
        all_ok=0
      fi
      local line_count
      line_count="$(grep -cve '^\s*$' -e '^\s*#' "$file" 2>/dev/null)" || line_count=0
      info "  Secret entries: $line_count"
    fi
    printf "\n" >&2
  }

  # Layered discovery
  local global_file="" project_file=""
  global_file="$(discover_global_file)" || true
  project_file="$(discover_project_file)" || true

  if [[ -n "$project_file" && "$project_file" == "$global_file" ]]; then
    global_file=""
  fi

  if [[ -n "$global_file" ]]; then
    _check_file "Global layer" "$global_file"
  else
    info "Global: none found (${XDG_CONFIG_HOME:-$HOME/.config}/agent-env/)"
    printf "\n" >&2
  fi

  if [[ -n "$project_file" ]]; then
    _check_file "Project layer" "$project_file"
  else
    info "Project: none found (searched PWD → git root)"
    printf "\n" >&2
  fi

  if [[ -z "$global_file" && -z "$project_file" ]]; then
    warn "No secrets file found at any layer"
    info "Run '$PROGRAM init' to create one"
    all_ok=0
  fi

  # Tool dependencies
  if command_exists sops; then
    success "sops: $(sops --version 2>&1 | head -1)"
  else
    warn "sops: not installed (needed for encrypted secrets)"
  fi

  if command_exists age; then
    success "age: $(age --version 2>&1 | head -1)"
  else
    warn "age: not installed (needed for age-encrypted SOPS files)"
  fi

  local age_key_file="${SOPS_AGE_KEY_FILE:-$HOME/.config/sops/age/keys.txt}"
  if [[ -f "$age_key_file" ]]; then
    success "Age key: $age_key_file"
  else
    warn "Age key: not found at $age_key_file"
  fi

  # Git safety
  if git rev-parse --is-inside-work-tree &>/dev/null; then
    if [[ -f .gitignore ]]; then
      if grep -qx '.env' .gitignore 2>/dev/null; then
        success ".gitignore: .env is excluded"
      else
        warn ".gitignore: .env is NOT excluded — secrets may be committed!"
      fi
    else
      warn "No .gitignore found"
    fi
  fi

  printf "\n" >&2
  if [[ "$all_ok" -eq 1 ]]; then
    success "All checks passed"
  else
    error "Some checks failed"
    return 1
  fi
}

# ---------------------------------------------------------------------------
# Subcommand: upgrade
# ---------------------------------------------------------------------------
cmd_upgrade() {
  # Find the repo: follow our own symlink, or use AGENT_ENV_HOME
  local install_dir=""
  local self="$HOME/.local/bin/agent-env"

  if [[ -L "$self" ]]; then
    local target
    target="$(readlink "$self")"
    # target is e.g. /path/to/clone/bin/agent-env — go up two levels
    local resolved
    resolved="$(cd "$(dirname "$target")/.." && pwd)"
    if [[ -d "$resolved/.git" ]]; then
      install_dir="$resolved"
    fi
  fi

  if [[ -z "$install_dir" ]]; then
    install_dir="${AGENT_ENV_HOME:-$HOME/.local/share/agent-env}"
  fi

  if [[ ! -d "$install_dir/.git" ]]; then
    die "Cannot find agent-env git repo. Reinstall with: curl -fsSL https://raw.githubusercontent.com/jordanburke/agent-env/main/install.sh | bash"
  fi

  info "Updating from $install_dir..."
  git -C "$install_dir" pull --ff-only || die "Git pull failed"
  success "Upgraded to $(git -C "$install_dir" describe --tags --always 2>/dev/null || echo 'latest')"
}

# ---------------------------------------------------------------------------
# Subcommand: uninstall
# ---------------------------------------------------------------------------
cmd_uninstall() {
  local auto_yes=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--yes) auto_yes=1; shift ;;
      *)        die "Unknown uninstall option: $1" ;;
    esac
  done

  local bin_link="$HOME/.local/bin/agent-env"

  printf "\n${BOLD}agent-env uninstaller${RESET}\n\n" >&2

  # Remove symlink / binary
  if [[ -L "$bin_link" ]]; then
    rm "$bin_link"
    success "Removed $bin_link"
  elif [[ -f "$bin_link" ]]; then
    rm "$bin_link"
    success "Removed $bin_link"
  else
    info "No binary link found at $bin_link"
  fi

  # Remove cloned repo (if standard install location)
  local install_dir="${AGENT_ENV_HOME:-$HOME/.local/share/agent-env}"
  if [[ -d "$install_dir" ]]; then
    if [[ "$auto_yes" -eq 1 ]]; then
      rm -rf "$install_dir"
      success "Removed $install_dir"
    else
      printf "\n  Remove cloned repository at ${BOLD}%s${RESET}? [y/N] " "$install_dir" >&2
      read -r response
      if [[ "$response" =~ ^[Yy]$ ]]; then
        rm -rf "$install_dir"
        success "Removed $install_dir"
      else
        info "Kept $install_dir"
      fi
    fi
  fi

  # What we don't touch
  printf "\n${YELLOW}The following were NOT removed (your secrets are safe):${RESET}\n" >&2
  info ".env and .sops.env files in your projects"
  info "~/.config/agent-env/ (global secrets)"
  info "~/.config/sops/age/keys.txt (age encryption keys)"
  info ".sops.yaml files in your projects"

  printf "\n${GREEN}agent-env has been uninstalled.${RESET}\n\n" >&2
}

# ---------------------------------------------------------------------------
# Subcommand: help
# ---------------------------------------------------------------------------
cmd_help() {
  cat <<EOF
${BOLD}agent-env${RESET} v${VERSION} — Universal secret injection for AI coding agents

${BOLD}USAGE${RESET}
  $PROGRAM <command> [options]

${BOLD}COMMANDS${RESET}
  ${GREEN}run${RESET} <agent> [args...]   Inject secrets and launch an AI agent
  ${GREEN}init${RESET} [--sops]           Create a new secrets file (.env or .sops.env)
  ${GREEN}edit${RESET}                    Edit secrets file (sops edit or \$EDITOR)
  ${GREEN}view${RESET}                    View decrypted secrets
  ${GREEN}check${RESET}                   Verify setup (files, tools, keys)
  ${GREEN}upgrade${RESET}                 Self-update from git
  ${GREEN}uninstall${RESET}               Remove agent-env
  ${GREEN}version${RESET}                 Print version
  ${GREEN}help${RESET}                    Show this help

${BOLD}RUN OPTIONS${RESET}
  -v, --verbose         Show discovery and loading steps
  --env FILE            Use a specific secrets file
  --secrets FILE        Alias for --env
  --sops                Force SOPS mode
  --dotenv              Force dotenv mode
  --no-global           Skip loading global secrets layer

${BOLD}EXAMPLES${RESET}
  $PROGRAM claude                        # Run Claude Code with secrets (shorthand)
  $PROGRAM run claude                    # Same thing, explicit form
  $PROGRAM run --verbose aider           # Run Aider with verbose output
  $PROGRAM run --env ~/.secrets codex    # Use specific secrets file
  $PROGRAM run --no-global claude        # Skip global layer
  $PROGRAM init                          # Create .env in current directory
  $PROGRAM init --sops                   # Create encrypted .sops.env
  $PROGRAM check                         # Verify everything is set up

${BOLD}LAYERED SECRETS${RESET}
  Secrets load in two layers (project values override global):

  Layer 1 — Global (base):
    \$XDG_CONFIG_HOME/agent-env/.sops.env  (~/.config/agent-env/.sops.env)
    \$XDG_CONFIG_HOME/agent-env/.env       (~/.config/agent-env/.env)
    ~/.sops.env
    ~/.env

  Layer 2 — Project (overlay):
    Current directory, walking up to git root (.sops.env or .env)

${BOLD}MORE INFO${RESET}
  https://github.com/jordanburke/agent-env
EOF
}

# ---------------------------------------------------------------------------
# Subcommand: version
# ---------------------------------------------------------------------------
cmd_version() {
  printf "%s %s\n" "$PROGRAM" "$VERSION"
}

# ---------------------------------------------------------------------------
# Main dispatch
# ---------------------------------------------------------------------------
main() {
  if [[ $# -eq 0 ]]; then
    cmd_help
    exit 0
  fi

  local command="$1"
  shift

  case "$command" in
    run)      cmd_run "$@" ;;
    init)     cmd_init "$@" ;;
    edit)     cmd_edit "$@" ;;
    view)     cmd_view "$@" ;;
    check)    cmd_check "$@" ;;
    upgrade)   cmd_upgrade "$@" ;;
    uninstall) cmd_uninstall "$@" ;;
    version)   cmd_version "$@" ;;
    help|-h|--help) cmd_help "$@" ;;
    -v|--version)   cmd_version "$@" ;;
    *)
      # Treat unknown commands as implicit "run" — e.g. "agent-env claude" → "agent-env run claude"
      cmd_run "$command" "$@"
      ;;
  esac
}

main "$@"
